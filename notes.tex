\documentclass[fontsize=11pt,a4paper]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{amsmath, amssymb, amsopn}
\usepackage{xcolor} % include before tikz!
\usepackage{tikz}
\usepackage[european]{circuitikz}
\usepackage{nicefrac}
\usepackage{trfsigns} % for \laplace,\Laplace
\usepackage{booktabs}
%\usepackage{framed}
%\usepackage{geometry}
%\geometry{left=0.5cm,right=0.5cm,top=0.5cm,bottom=0.5cm}
\setlength{\parskip}{7pt}
\setlength{\parindent}{0em}
%
%
%
\usepackage[osf]{libertine}
\usepackage{zi4}
\usepackage[libertine,cmbraces]{newtxmath}
%
%
%
%
\DeclareMathOperator{\grad}{grad}
\DeclareMathOperator{\Div}{div}
\DeclareMathOperator{\rot}{rot}
\DeclareMathOperator{\sinc}{sinc}
%
%
%
%
\usepackage{listings}
%\usepackage{bytefield}
%
%
%
%
\begin{document}
\clearpage
\begingroup
	\pagestyle{empty}
	\begin{center}
		\LARGE{\textbf{Notes}}
	\end{center}
	\hfill
	\tableofcontents
	\clearpage
\endgroup
\newpage
\setcounter{page}{1}
%
%
%
%
\lstset{numbers=left,
	frame=single,
	numberstyle=\tiny,
	basicstyle=\footnotesize,
	showstringspaces=false,
	%keywordstyle=\color{blue},
	%commentstyle=\em\color{gray},
	tabsize=3,
	numbersep=5pt,
	%morecomment=[s][\color{blue}]{<<<}{>>>},
	%morekeywords={float3,float4,__device__,__global__,__shared__,__constant__,threadIdx,blockIdx,blockDim,gridDim,\_\_syncthreads}}
}
%
%
%
\section{Verilog}
\subsection{Synthesis}
\lstset{language=verilog}
Listing \ref{lst:basic_structure} shows the basic structure of a Verilog module. Identifiers are case-sensitive.
\begin{figure}[htb]
\begin{lstlisting}
// Single line comment
/* Comment spanning
   several lines */

module some_module (
	// Ports
	input [wire/reg] in1,
	input in2,
	output [wire/reg] out
);
	// Internal signals
	wire signal1, signal2;

	// Vector, bus (32 bits wide)
	wire [31:0] bus;

	// Examples for accessing part of a vector:
	// bus[0], bus[7:0]

	// Local parameter, cannot be changed
	localparam PARAM = 42;

endmodule
\end{lstlisting}
\caption{Basic structure of a Verilog module}
\label{lst:basic_structure}
\end{figure}

Signals can take the values \lstinline!0! (logic $0$), \lstinline!1! (logic $1$), \lstinline!x! (undefined, uninitialized) and \lstinline!z! (high impedance).

Integer constants: \lstinline!<bits>'<base><literal>! (leaving out \lstinline!<bits>! defaults to a width of at least 32 bits, underscores in \lstinline!<literal>! are ignored). Valid values for \lstinline!<base>!: \lstinline!b! (binary), \lstinline!d! (decimal), \lstinline!o! (octal) and \lstinline!h! (hexadecimal). Examples: \lstinline!4'b01_01!, \lstinline!8'hab!, \lstinline!10!.

Instantiating modules or primitives connecting ports by sequence:
\begin{lstlisting}
some_module instance_name (
	// Inputs and outputs in the same order
	// as the appear in the declaration of some_module
	in1,
	in2,
	out
);
\end{lstlisting}

Connecting the ports by name:
\begin{lstlisting}
some_module instance_name (
	.IN1(in1),
	.IN2(in2),
	.OUT(out)
);
\end{lstlisting}

Dataflow modeling (combinatorial circuit)
\begin{lstlisting}
module my_xor (
	input a,
	input b,
	output y
);

	assign y = a ^ b;

endmodule
\end{lstlisting}

Operators
\begin{table}[htb]
	\centering
	\begin{tabular}{lll}
	\toprule
		\textbf{Operator} & \textbf{Type} & \textbf{Meaning} \\
	\midrule
		\lstinline!&! & Bitwise & AND \\
		\lstinline!|! & Bitwise & OR \\
		\lstinline!^! & Bitwise & Exclusive OR \\
		\lstinline!~! & Bitwise & One's complement \\
		\lstinline!{a, b, c}! & Other & Concatenate wires or vectores \\
		... & ... & ...\\
	\bottomrule
	\end{tabular}
	\caption{Verilog operators}
	\label{tab:operators}
\end{table}

Behavioral modeling using \lstinline!always! blocks:
\begin{lstlisting}
// Synchronous logic
// Edge triggered
always @(posedge clock, negedge reset) begin
	if (reset)
		counter <= 0;
	else
		counter <= counter + 1;
end

// Asynchronous logic
// Sensitive to all signals in block, level triggered
always @* begin
	// ...
end
\end{lstlisting}

Non-blocking assignment: \lstinline!signal <= /* ... */!

Blocking assignment: \lstinline!signal = /* ... */!

Switch case
\begin{lstlisting}
case (signal)
	value1: /* instruction / block */
	value2: /* instruction / block */
	// ...
	default: /* instruction / block */
endcase
\end{lstlisting}

\lstinline!casez! treats \lstinline!z!, \lstinline!casex! \lstinline!x! and \lstinline!z! as don't care values.

Use default values to avoid inference of latches/ registers.

Modeling of memory with arrays:
\begin{lstlisting}
// 256 bytes of memory
reg [7:0] mem [0:255];
//    ^         ^
//    |         |
//    |         -- Number of cells
//    ------------ Memory width
\end{lstlisting}

Tristate ports: \lstinline!inout!, Pull-down: \lstinline!tri0!, Pull-up: \lstinline!tri1!, Wired-AND: \lstinline!wand! or \lstinline!triand!, Wired-OR: \lstinline!wor! or \lstinline!trior!

Declaration and instantiation of modules with parameters:
\begin{lstlisting}
module some_module #(
	// Parameters with default values
	parameter PARAM1 = 1,
	parameter PARAM2 = 2
)(
	input in,
	output out
);

	/* ... */

endmodule

// Instantiation of the module above
some_module #(
	.PARAM1(param1),
	.PARAM2(param2)
) instance_name (
	/* ... */
);
\end{lstlisting}

Functions: only combinational circuits, no registers, delays and non-blocking assignments (are defined in the module in which they are used, can call other functions).
\begin{lstlisting}
function my_xor;
	input a, b;

	begin
		my_xor = a ^ b;
	end
endfunction

assign y = my_xor(c, d);
\end{lstlisting}

Tasks: no return value, can have \lstinline!ouput! and \lstinline!inout! ports, can have delays
\begin{lstlisting}
task my_inverter;
	// FIXME
\end{lstlisting}

\lstinline!generate! Blocks:
\begin{lstlisting}
	// FIXME
\end{lstlisting}

Compiler directives: FIXME
%
%
%
%
\subsection{Simulation}
Register data types: \lstinline!integer!, \lstinline!real!, \lstinline!time!

Initial blocks:
\begin{lstlisting}
module testbench;
	initial begin
		$display("Hello world!);
		$finish;
	end
endmodule
\end{lstlisting}

Delays: \lstinline!#10;!

System tasks: \lstinline!$display("Format string", /* ... */)!

\lstinline!$monitor("Format string", /* ... */)!: automatically generates output when one of the values changes

VCD (Value Change Dump) files:
\begin{lstlisting}
$dumpfile("traces.vcd")
$dumpvars(0, testbench)
\end{lstlisting}
%
%
%
%
%
\section{VHDL}
\lstset{language=vhdl,
        morecomment=[s]{/*}{*/}}
\subsection{Lexical Elements}
Types of \emph{comments} (can't be nested):
\begin{lstlisting}
-- Single line comment
/* Comment spanning multiple
   lines (VHDL-2008 only) */
\end{lstlisting}

Valid \emph{identifiers} consist of the characters \lstinline!'a'!--\lstinline!'z'!, \lstinline!'A'!--\lstinline!'Z'!, \lstinline!'0'!--\lstinline!'9'!, \lstinline!'_'! and may only start with an alphabetic letter. Identifiers with more than one consecutive underscore or identifiers that end with an underscore are illegal. Furthermore, identifiers aren't case sensitive in VHDL.

Examples of \emph{numeric literals}:
\begin{lstlisting}
-- Integer literals (base 10)
1 42 10e5 10E6
1_234           -- identical to 1234, underscores get ignored

-- Real literals (base 10, always contain the decimal point '.' character)
3.1415927 1.6022e-19 8.8542E-12

-- Other bases
2#10101010#   -- binary integer
8#777#        -- octal integer
16#aa# 16#FF# -- hexadecimal integer
2#1.101#      -- binary real
\end{lstlisting}

Examples of \emph{character and string literals}:
\begin{lstlisting}
-- Characters (ISO 8859 Latin-1 8 bit character set)
'a' 'b' 'X' '_'
'''             -- single quote

-- Strings (may not be separated by linebreaks)
"Hello world!"
""""           -- double quote
""             -- empty string
\end{lstlisting}

\newpage
\emph{Bit string literals} are enclosed in double quotes with a prefix that indicates the size of the string in bits (\textsc{VHDL-2008} only) and the base. Examples:
\begin{lstlisting}
b"101010" B"1111_0000" -- binary (underscores are ignored)
o"777" O"777"          -- octal
x"aabb" X"FFFF"        -- hexadecimal

-- VHDL-2008 only
8b"1111_0000" -- 8 bit long binary number
d"42" D"23"   -- decimal number, size can't be specified

X"0X1"       -- equivalent to B"0000XXXX1111"
B"1111_ZZ00" -- equivalent to B"1111ZZ00"

UB"" UO"" UX"" -- unsigned binary, octal, hexadecimal
SB"" SO"" SX"" -- signed     "       "         "
\end{lstlisting}
%
%
%
%
\subsection{Fundamental Data Types}
Declaring \emph{constants} (one of several types of objects, namely constants, variables, signals and files): \lstinline!constant identifier {, ...}: subtype [:= initial_value];!  

Examples:
\begin{lstlisting}
constant pi : real    := 3.1415927;
constant n  : natural := 42;
\end{lstlisting}

Declaring \emph{variables}: \lstinline!variable identifier {, ...}: subtype [:= initial_value];!

Examples:
\begin{lstlisting}
variable count : integer := 0;
variable x     : natural;
\end{lstlisting}

\emph{Assignments} to variables are non-blocking (in contrast to assignments to signals), i.e. the value of the variable gets updated immediately: \lstinline![label:] name := value;!

Examples:
\begin{lstlisting}
x     := 1;
count := count + 1;
\end{lstlisting}

New \emph{types} can be declared using \lstinline!type identifier is definition;!.

Declaring new \emph{integer} types: \lstinline!type identifier is range bound1 (to|downto) bound2;!

Example:
\begin{lstlisting}
type day_of_week is range 0 to 6;

constant JAN : integer := 1;
constant DEC : integer := 12;
type month is range JAN to DEC;  -- bounds for range can be evaluated
                                 -- at compile time
\end{lstlisting}
Operations that are defined for integer types include \lstinline!+!, \lstinline !-!, \lstinline!*!, \lstinline!/!, \lstinline!mod!, \lstinline!rem!, \lstinline!abs! and \lstinline!**!.

New \emph{floating point} types are declared exactly as their integer counterparts, except the bounds for their range have to evaluate to real numbers. If the default value for floating point variables is left out, they default to the lowest possible value.

\emph{Physical} types include a physical unit and can be declared as follows:
\begin{lstlisting}
type identifier is range bound1 (to|downto) bound2
	units
		identifier;
		{identifier2 = (integer/real) unit;}
	end units [identifier];
\end{lstlisting}

Example:
\begin{lstlisting}
type voltage is range 0 to 1e9
	units
		volt;              -- base unit
		kvolt = 1000 volt;
	end units voltage;
\end{lstlisting}
VHDL includes a predefined physical type \lstinline!time!, that defines the following unit prefixes: \lstinline!fs!, \lstinline!ps!, \lstinline!ns!, \lstinline!us!, \lstinline!ms!, \lstinline!sec!, \lstinline!min! and \lstinline!hr!.

Declaring \emph{enumeration} types: \lstinline!type identifier is ( (identifier|character literal) {, ...} );!

Examples:
\begin{lstlisting}
type fsm_state is (reset, state1, state2);
variable state : fsm_state := reset;

type hexdigit is ('0','1','2','3','4','5','6','7','8','9',
                   'a','b','c','d','e','f'); -- lowercase hex digits
variable x : hexdigit := 'a';

-- Predefined character enumeration type
variable c : character := 'x';
\end{lstlisting}

The predefined \lstinline!boolean! enumeration type can take the values \lstinline!true! and \lstinline!false!. Valid expressions including booleans may use the operators \lstinline!=! (is equal), \lstinline!/=! (is not equal), \lstinline!and!, \lstinline!or!, \lstinline!nand!, \lstinline!nor!, \lstinline!not!, \lstinline!xor! and \lstinline!xnor!.

Predefined \lstinline!bit! type: \lstinline!type bit is ('0', '1');! (overloads \lstinline!'0'! and \lstinline!'1'! character literals).

Declaring \emph{subtypes}: \lstinline!subtype identifier is type range bound1 (to|downto) bound2;!

Examples:
\begin{lstlisting}
subtype uint8 is integer range 0 to 255;

variable b : uint8 := 255;

-- Predefined subtype for delays >=0 fs
variable delay : delay_length;
\end{lstlisting}

The \emph{type qualification} operator \lstinline!typename'(expression)! can be used to distinguish between overloaded enumeration literals:
\begin{lstlisting}
type fsm1_state is (reset, a1, a2);
type fsm2_state is (reset, b1, b2);

fsm1_state'(reset) -- type of 'reset' literal: fsm1_state
fsm2_state'(reset) -- type of 'reset' literal: fsm2_state
\end{lstlisting}

Examples for \emph{type conversions}:
\begin{lstlisting}
real(42)         -- integer to real
integer(2.71828) -- real to integer
\end{lstlisting}

List of \emph{attributes} applicable to scalar data types (\lstinline!T! denotes a type name):

%\centering
\begin{tabular}{lll}
\toprule
	\textbf{Attribute} & \textbf{Description}\\
\midrule
	\lstinline!T'ascending! & \lstinline!True!: ascending range, \lstinline!false!: descending range \\
	\lstinline!T'low! & Lowest possible value\\
	\lstinline!T'high! & Highest possible value\\
	\lstinline!T'left! & Leftmost element\\
	\lstinline!T'right! & Rightmost element\\
	\lstinline!T'image(value)! & Converts \lstinline!value! to string representation\\
	\lstinline!T'value(string)! & Converts \lstinline!string! to value\\
\bottomrule
\end{tabular}


List of additional attributes applicable to discrete and physical types:

%\centering
\begin{tabular}{lll}
\toprule
	\textbf{Attribute} & \textbf{Description}\\
\midrule
	\lstinline!T'pos(value)! & Index of \lstinline!value!\\
	\lstinline!T'val(j)! & Value at index \lstinline!j!\\
	\lstinline!T'succ(value)! & \lstinline!Value! incremented by one\\
	\lstinline!T'pred(value)! & \lstinline!Value! decremented by one\\
	\lstinline!T'leftof(value)! & Element to the left of \lstinline!value!\\
	\lstinline!T'rightof(value)! & Element to the right of \lstinline!value!\\
\bottomrule
\end{tabular}
%
%
%
%
\subsection{Sequential Control Flow Constructs}
Syntax of \emph{if} statements:
\begin{lstlisting}
[label:]
-- VHDL-2008 only: implicit conversion of 'expression' to boolean
if expression then
	{...}
{elsif expression then
	{...}}
[else                   -- default branch
	{...}]
end if [label];
\end{lstlisting}

Example:
\begin{lstlisting}
entity bincnt is
	port (clk : in std_logic;
	      led1, led2, led3, led4, led5 : out std_logic);
end bincnt;

architecture behavioral of bincnt is
	signal cnt : unsigned (4 downto 0) := (others => '0');
begin
	process (clk)
		variable delay : unsigned (23 downto 0) := (others => '0');
	begin
		if rising_edge(clk) then
			if delay = 2_999_999 then
				cnt <= cnt + 1;
				delay := x"000000";
			else
				delay := delay + 1;
			end if;
		end if;
	end process;

	(led5,led4,led3,led2,led1) <= std_logic_vector(cnt);
end behavioral;
\end{lstlisting}

Syntax of \emph{conditional variable assignments} (VHDL-2008 only):
\begin{lstlisting}
[label:]
variable := value when expression
	{else value when expression}
	[else expression];            -- default branch
\end{lstlisting}

Syntax of \emph{case} statements:
\begin{lstlisting}
[label:]
case expression is
	when (expression
	      | bound1 (to|downto) bound2 -- discrete range
	      | subtype                   -- name of subtype
	      | others                    -- default branch)
	=> {...}
end case [label];
\end{lstlisting}
Multiple alternatives in a \lstinline!when! statement can be separated by the \lstinline!|! character, e.g.
\begin{lstlisting}
case x is
	when 1|2 =>
		y <= 1;
	when 3   =>
		y <= 2;
	when others
		y <= 3;
end case;
\end{lstlisting}

Another example of a case statement:
\begin{lstlisting}
entity mux4 is
	port (a0, a1, a2, a3 : in  bit;
	      sel0, sel1     : in  bit;
	      y              : out bit);
	constant T_PD : delay_length := 4.5 ns;
end entity mux4;

architecture behav of mux4 is
	signal sel : bit_vector(0 to 1);
begin
	sel <= (sel0, sel1);

	process (sel, a0, a1, a2, a3) is
	begin
		case sel is
			when "00" => y <= a0 after T_PD;
			when "01" => y <= a1 after T_PD;
			when "10" => y <= a2 after T_PD;
			when "11" => y <= a3 after T_PD;
		end case;
	end process;
end architecture behav;
\end{lstlisting}

Syntax of \emph{selected variable assignments} (VHDL-2008 only):
\begin{lstlisting}
[label:]
with expression select
variable := {value when expression,}
	value when expression;
\end{lstlisting}

\emph{Null} statements (no operation): \lstinline![label:] null;!.

General syntax of \emph{loops}:
\begin{lstlisting}
[label:]
[while expression                               -- boolean expression
 | for identifier in bound1 (to|downto) bound2] -- discrete range
loop                                            -- loops forever without
                                                -- while or for
	{...}
end loop [label];
\end{lstlisting}

Loops can be aborted with the \lstinline!exit! statement: \lstinline![label:] exit [label_loop] [when expression];!; to continue with the next iteration of the loop one can use the \lstinline!next! statement:\\ \lstinline![label:] next [label_loop] [when expression];!.

Example of a loop without \lstinline!while! or \lstinline!for!:
\begin{lstlisting}
entity counter is
	port (clk   : in bit;
	      count : out natural);
end entity counter;

architecture behav of counter is
begin
	process is
		variable c : natural := 15;
	begin
		count <= c;
		loop
			wait until clk = '1';
			c := c - 1 when c /= 0
			     else 15;
			count <= c;
		end loop;
	end process;
end architecture behav;
\end{lstlisting}

Example of a \emph{for loop}:
\begin{lstlisting}
entity average is
	port (clk  : in bit;
	      din  : in real;
	      dout : out real);
end entity average;

architecture behav of average is
	constant N : integer := 4;
begin
	process is
		variable sum : real;
	begin
		loop
			sum := 0.0;
			for i in 0 to N-1 loop
				wait until clk = '1';
				sum := sum + din;
			end loop;

			dout <= sum / real(N);
		end loop;
	end process;
end architecture behav;
\end{lstlisting}

Syntax of \emph{assertions} (for simulation, synthesis or formal verification):
\begin{lstlisting}
[label:] assert expression
         [report expression] [severity level];

-- Valid values for level:
-- note, warning, error, failure
\end{lstlisting}

\emph{Report} statements are equivalent to unconditional assertions:\\ \lstinline![label:] report expression [severity level];!.
\end{document}
