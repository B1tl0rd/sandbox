\documentclass[fontsize=11pt,a4paper]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{amsmath, amssymb, amsopn}
\usepackage{xcolor} % include before tikz!
\usepackage{tikz}
\usepackage[european]{circuitikz}
\usepackage{nicefrac}
\usepackage{trfsigns} % for \laplace,\Laplace
\usepackage{booktabs}
%\usepackage{framed}
%\usepackage{geometry}
%\geometry{left=0.5cm,right=0.5cm,top=0.5cm,bottom=0.5cm}
\setlength{\parskip}{7pt}
\setlength{\parindent}{0em}
%
%
%
\usepackage[osf]{libertine}
\usepackage{zi4}
\usepackage[libertine,cmbraces]{newtxmath}
%
%
%
%
\DeclareMathOperator{\grad}{grad}
\DeclareMathOperator{\Div}{div}
\DeclareMathOperator{\rot}{rot}
\DeclareMathOperator{\sinc}{sinc}
\DeclareMathOperator{\curl}{curl}
%
%
%
%
\usepackage{listings}
%\usepackage{bytefield}
%
%
%
%
\usepackage{datetime} % for \currenttime
\usepackage{braket}
%
%
%
%
\begin{document}
\clearpage
\begingroup
	\pagestyle{empty}
	\begin{center}
		\LARGE{\textbf{Notes}}

		\small{Compiled on {\today} at \currenttime}
	\end{center}
	\hfill
	\tableofcontents
	\clearpage
\endgroup
\newpage
\setcounter{page}{1}
%
%
%
%
\lstset{numbers=left,
	frame=single,
	numberstyle=\tiny,
	basicstyle=\footnotesize,
	showstringspaces=false,
	%keywordstyle=\color{blue},
	%commentstyle=\em\color{gray},
	tabsize=3,
	numbersep=5pt,
	%morecomment=[s][\color{blue}]{<<<}{>>>},
	%morekeywords={float3,float4,__device__,__global__,__shared__,__constant__,threadIdx,blockIdx,blockDim,gridDim,\_\_syncthreads}}
}
%
%
%
\section{Verilog}
\subsection{Synthesis}
\lstset{language=verilog}
Listing \ref{lst:basic_structure} shows the basic structure of a Verilog module. Identifiers are case-sensitive.
\begin{figure}[htb]
\begin{lstlisting}
// Single line comment
/* Comment spanning
   several lines */

module some_module (
	// Ports
	input [wire/reg] in1,
	input in2,
	output [wire/reg] out
);
	// Internal signals
	wire signal1, signal2;

	// Vector, bus (32 bits wide)
	wire [31:0] bus;

	// Examples for accessing part of a vector:
	// bus[0], bus[7:0]

	// Local parameter, cannot be changed
	localparam PARAM = 42;

endmodule
\end{lstlisting}
\caption{Basic structure of a Verilog module}
\label{lst:basic_structure}
\end{figure}

Signals can take the values \lstinline!0! (logic $0$), \lstinline!1! (logic $1$), \lstinline!x! (undefined, uninitialized) and \lstinline!z! (high impedance).

Integer constants: \lstinline!<bits>'<base><literal>! (leaving out \lstinline!<bits>! defaults to a width of at least 32 bits, underscores in \lstinline!<literal>! are ignored). Valid values for \lstinline!<base>!: \lstinline!b! (binary), \lstinline!d! (decimal), \lstinline!o! (octal) and \lstinline!h! (hexadecimal). Examples: \lstinline!4'b01_01!, \lstinline!8'hab!, \lstinline!10!.

Instantiating modules or primitives connecting ports by sequence:
\begin{lstlisting}
some_module instance_name (
	// Inputs and outputs in the same order
	// as the appear in the declaration of some_module
	in1,
	in2,
	out
);
\end{lstlisting}

Connecting the ports by name:
\begin{lstlisting}
some_module instance_name (
	.IN1(in1),
	.IN2(in2),
	.OUT(out)
);
\end{lstlisting}

Dataflow modeling (combinatorial circuit)
\begin{lstlisting}
module my_xor (
	input a,
	input b,
	output y
);

	assign y = a ^ b;

endmodule
\end{lstlisting}

Operators
\begin{table}[htb]
	\centering
	\begin{tabular}{lll}
	\toprule
		\textbf{Operator} & \textbf{Type} & \textbf{Meaning} \\
	\midrule
		\lstinline!&! & Bitwise & AND \\
		\lstinline!|! & Bitwise & OR \\
		\lstinline!^! & Bitwise & Exclusive OR \\
		\lstinline!~! & Bitwise & One's complement \\
		\lstinline!{a, b, c}! & Other & Concatenate wires or vectores \\
		... & ... & ...\\
	\bottomrule
	\end{tabular}
	\caption{Verilog operators}
	\label{tab:operators}
\end{table}

Behavioral modeling using \lstinline!always! blocks:
\begin{lstlisting}
// Synchronous logic
// Edge triggered
always @(posedge clock, negedge reset) begin
	if (reset)
		counter <= 0;
	else
		counter <= counter + 1;
end

// Asynchronous logic
// Sensitive to all signals in block, level triggered
always @* begin
	// ...
end
\end{lstlisting}

Non-blocking assignment: \lstinline!signal <= /* ... */!

Blocking assignment: \lstinline!signal = /* ... */!

Switch case
\begin{lstlisting}
case (signal)
	value1: /* instruction / block */
	value2: /* instruction / block */
	// ...
	default: /* instruction / block */
endcase
\end{lstlisting}

\lstinline!casez! treats \lstinline!z!, \lstinline!casex! \lstinline!x! and \lstinline!z! as don't care values.

Use default values to avoid inference of latches/ registers.

Modeling of memory with arrays:
\begin{lstlisting}
// 256 bytes of memory
reg [7:0] mem [0:255];
//    ^         ^
//    |         |
//    |         -- Number of cells
//    ------------ Memory width
\end{lstlisting}

Tristate ports: \lstinline!inout!, Pull-down: \lstinline!tri0!, Pull-up: \lstinline!tri1!, Wired-AND: \lstinline!wand! or \lstinline!triand!, Wired-OR: \lstinline!wor! or \lstinline!trior!

Declaration and instantiation of modules with parameters:
\begin{lstlisting}
module some_module #(
	// Parameters with default values
	parameter PARAM1 = 1,
	parameter PARAM2 = 2
)(
	input in,
	output out
);

	/* ... */

endmodule

// Instantiation of the module above
some_module #(
	.PARAM1(param1),
	.PARAM2(param2)
) instance_name (
	/* ... */
);
\end{lstlisting}

Functions: only combinational circuits, no registers, delays and non-blocking assignments (are defined in the module in which they are used, can call other functions).
\begin{lstlisting}
function my_xor;
	input a, b;

	begin
		my_xor = a ^ b;
	end
endfunction

assign y = my_xor(c, d);
\end{lstlisting}

Tasks: no return value, can have \lstinline!ouput! and \lstinline!inout! ports, can have delays
\begin{lstlisting}
task my_inverter;
	// FIXME
\end{lstlisting}

\lstinline!generate! Blocks:
\begin{lstlisting}
	// FIXME
\end{lstlisting}

Compiler directives: FIXME
%
%
%
%
\subsection{Simulation}
Register data types: \lstinline!integer!, \lstinline!real!, \lstinline!time!

Initial blocks:
\begin{lstlisting}
module testbench;
	initial begin
		$display("Hello world!);
		$finish;
	end
endmodule
\end{lstlisting}

Delays: \lstinline!#10;!

System tasks: \lstinline!$display("Format string", /* ... */)!

\lstinline!$monitor("Format string", /* ... */)!: automatically generates output if one of the values changes

VCD (Value Change Dump) files:
\begin{lstlisting}
$dumpfile("traces.vcd")
$dumpvars(0, testbench)
\end{lstlisting}
%
%
%
%
%
\section{VHDL}
\lstset{language=vhdl,
        morecomment=[s]{/*}{*/},
	morekeywords={unaffected}
}
\subsection{Lexical Elements}
Types of \emph{comments} (can't be nested):
\begin{lstlisting}
-- Single line comment
/* Comment spanning multiple
   lines (VHDL-2008 only) */
\end{lstlisting}

Valid \emph{identifiers} consist of the characters \lstinline!'a'!--\lstinline!'z'!, \lstinline!'A'!--\lstinline!'Z'!, \lstinline!'0'!--\lstinline!'9'!, \lstinline!'_'! and may only start with an alphabetic letter. Identifiers with more than one consecutive underscore or identifiers that end with an underscore are illegal. Furthermore, identifiers aren't case sensitive in VHDL.

Examples of \emph{numeric literals}:
\begin{lstlisting}
-- Integer literals (base 10)
1 42 10e5 10E6
1_234           -- Identical to 1234, underscores get ignored

-- Real literals (base 10, always contain the decimal point '.' character)
3.1415927 1.6022e-19 8.8542E-12

-- Other bases
2#10101010#   -- Binary integer
8#777#        -- Octal integer
16#aa# 16#FF# -- Hexadecimal integer
2#1.101#      -- Binary real
\end{lstlisting}

Examples of \emph{character and string literals}:
\begin{lstlisting}
-- Characters (ISO 8859 Latin-1 8 bit character set)
'a' 'b' 'X' '_'
'''             -- Single quote

-- Strings (may not be separated by linebreaks)
"Hello world!"
""""           -- Double quote
""             -- Empty string
\end{lstlisting}

\newpage
\emph{Bit string literals} are enclosed in double quotes with a prefix that indicates the size of the string in bits (\textsc{VHDL-2008} only) and the base. Examples:
\begin{lstlisting}
b"101010" B"1111_0000" -- Binary (underscores are ignored)
o"777" O"777"          -- Octal
x"aabb" X"FFFF"        -- Hexadecimal

-- VHDL-2008 only
8b"1111_0000" -- 8 bit long binary number
d"42" D"23"   -- Decimal number, size can't be specified

X"0X1"       -- Equivalent to B"0000XXXX1111"
B"1111_ZZ00" -- Equivalent to B"1111ZZ00"

UB"" UO"" UX"" -- Unsigned binary, octal, hexadecimal
SB"" SO"" SX"" -- Signed     "       "         "
\end{lstlisting}
%
%
%
%
\subsection{Fundamental Data Types}
Declaring \emph{constants} (one of several types of objects, namely constants, variables, signals and files): \lstinline!constant identifier {, ...}: type_name [:= initial_value];!  

Examples:
\begin{lstlisting}
constant pi : real    := 3.1415927;
constant n  : natural := 42;
\end{lstlisting}

Declaring \emph{variables}: \lstinline!variable identifier {, ...}: type_name [:= initial_value];!

Examples:
\begin{lstlisting}
variable count : integer := 0;
variable x     : natural;
\end{lstlisting}

\emph{Assignments} to variables are non-blocking (in contrast to assignments to signals), i.e. the value of the variable gets updated immediately: \lstinline![label_name:] identifier := value;!

Examples:
\begin{lstlisting}
x     := 1;
count := count + 1;
\end{lstlisting}

New \emph{types} can be declared using \lstinline!type identifier is definition;!.

Declaring new \emph{integer} types: \lstinline!type identifier is range bound1 (to|downto) bound2;!

Example:
\begin{lstlisting}
type day_of_week is range 0 to 6;

constant JAN : integer := 1;
constant DEC : integer := 12;
type month is range JAN to DEC;  -- Bounds for range can be evaluated
                                 -- at compile time
\end{lstlisting}
Operations that are defined for integer types include \lstinline!+!, \lstinline !-!, \lstinline!*!, \lstinline!/!, \lstinline!mod!, \lstinline!rem!, \lstinline!abs! and \lstinline!**!.

New \emph{floating point} types are declared exactly as their integer counterparts, except the bounds for their range have to evaluate to real numbers. If the default value for floating point variables is left out, they default to the lowest possible value.

\emph{Physical} types include a physical unit and can be declared as follows:
\begin{lstlisting}
type identifier is range bound1 (to|downto) bound2
	units
		identifier;
		{identifier2 = (integer_literal|real_literal) unit;}
	end units [identifier];
\end{lstlisting}

Example:
\begin{lstlisting}
type voltage is range 0 to 1e9
	units
		volt;              -- Base unit
		kvolt = 1000 volt;
	end units voltage;
\end{lstlisting}
VHDL includes a predefined physical type \lstinline!time!, that defines the following unit prefixes: \lstinline!fs!, \lstinline!ps!, \lstinline!ns!, \lstinline!us!, \lstinline!ms!, \lstinline!sec!, \lstinline!min! and \lstinline!hr!.

Declaring \emph{enumeration} types: \lstinline!type identifier is ( (identifier|character_literal) {, ...} );!

Examples:
\begin{lstlisting}
type fsm_state is (reset, state1, state2);
variable state : fsm_state := reset;

type hexdigit is ('0','1','2','3','4','5','6','7','8','9',
                  'a','b','c','d','e','f'); -- Lowercase hex digits
variable x : hexdigit := 'a';

-- Predefined character enumeration type
variable c : character := 'x';
\end{lstlisting}

The predefined \lstinline!boolean! enumeration type can take the values \lstinline!true! and \lstinline!false!. Valid expressions including booleans may use the operators \lstinline!=! (is equal), \lstinline!/=! (is not equal), \lstinline!and!, \lstinline!or!, \lstinline!nand!, \lstinline!nor!, \lstinline!not!, \lstinline!xor! and \lstinline!xnor!.

Predefined \lstinline!bit! type: \lstinline!type bit is ('0', '1');! (overloads \lstinline!'0'! and \lstinline!'1'! character literals).

Declaring \emph{subtypes}: \lstinline!subtype identifier is type_name range bound1 (to|downto) bound2;!

Examples:
\begin{lstlisting}
subtype uint8 is integer range 0 to 255;

variable b : uint8 := 255;

-- Predefined subtype for delays >=0 fs
variable delay : delay_length;
\end{lstlisting}

The \emph{type qualification} operator \lstinline!typename'(expression)! can be used to distinguish between overloaded enumeration literals:
\begin{lstlisting}
type fsm1_state is (reset, a1, a2);
type fsm2_state is (reset, b1, b2);

fsm1_state'(reset) -- Type of reset literal: fsm1_state
fsm2_state'(reset) -- Type of reset literal: fsm2_state
\end{lstlisting}

Examples for \emph{type conversions}:
\begin{lstlisting}
real(42)         -- Integer to real
integer(2.71828) -- Real to integer
\end{lstlisting}

List of \emph{attributes} applicable to scalar data types (\lstinline!T! denotes a type name):

%\centering
\begin{tabular}{ll}
\toprule
	\textbf{Attribute} & \textbf{Description}\\
\midrule
	\lstinline!T'ascending! & \lstinline!True!: ascending range, \lstinline!false!: descending range \\
	\lstinline!T'low! & Lowest possible value\\
	\lstinline!T'high! & Highest possible value\\
	\lstinline!T'left! & Leftmost element\\
	\lstinline!T'right! & Rightmost element\\
	\lstinline!T'image(value)! & Converts \lstinline!value! to string representation\\
	\lstinline!T'value(string)! & Converts \lstinline!string! to value\\
\bottomrule
\end{tabular}


List of additional attributes applicable to discrete and physical types (\lstinline!T! denotes a type name):

%\centering
\begin{tabular}{ll}
\toprule
	\textbf{Attribute} & \textbf{Description}\\
\midrule
	\lstinline!T'pos(value)! & Index of \lstinline!value!\\
	\lstinline!T'val(j)! & Value at index \lstinline!j!\\
	\lstinline!T'succ(value)! & \lstinline!Value! incremented by one\\
	\lstinline!T'pred(value)! & \lstinline!Value! decremented by one\\
	\lstinline!T'leftof(value)! & Element to the left of \lstinline!value!\\
	\lstinline!T'rightof(value)! & Element to the right of \lstinline!value!\\
\bottomrule
\end{tabular}
%
%
%
%
\subsection{Sequential Control Flow Constructs}
Syntax of \emph{if} statements:
\begin{lstlisting}
[label_name:]
-- VHDL-2008 only: implicit conversion of 'expression' to boolean
if expression then
	{...}
{elsif expression then
	{...}}
[else                   -- Default branch
	{...}]
end if [label_name];
\end{lstlisting}

Example:
\begin{lstlisting}
entity bincnt is
	port (clk : in std_logic;
	      led1, led2, led3, led4, led5 : out std_logic);
end bincnt;

architecture behavioral of bincnt is
	signal cnt : unsigned (4 downto 0) := (others => '0');
begin
	process (clk)
		variable delay : unsigned (23 downto 0) := (others => '0');
	begin
		if rising_edge(clk) then
			if delay = 2_999_999 then
				cnt <= cnt + 1;
				delay := x"000000";
			else
				delay := delay + 1;
			end if;
		end if;
	end process;

	(led5,led4,led3,led2,led1) <= std_logic_vector(cnt);
end behavioral;
\end{lstlisting}

Syntax of \emph{conditional variable assignments} (VHDL-2008 only):
\begin{lstlisting}
[label_name:]
variable := value when expression
	{else value when expression}
	[else expression];            -- Default branch
\end{lstlisting}

Syntax of \emph{case} statements:
\begin{lstlisting}
[label_name:]
case expression is
	when (expression
	      | bound1 (to|downto) bound2 -- Discrete range
	      | subtype_name              -- Name of subtype
	      | others)                   -- Default branch
	=> {...}
end case [label_name];
\end{lstlisting}
Multiple alternatives in a \lstinline!when! statement can be separated with the ``\lstinline!|!'' character, e.g.
\begin{lstlisting}
case x is
	when 1|2 =>
		y <= 1;
	when 3   =>
		y <= 2;
	when others
		y <= 3;
end case;
\end{lstlisting}

Another example of a case statement:
\begin{lstlisting}
entity mux4 is
	port (a0, a1, a2, a3 : in  bit;
	      sel0, sel1     : in  bit;
	      y              : out bit);
	constant T_PD : delay_length := 4.5 ns;
end entity mux4;

architecture behav of mux4 is
	signal sel : bit_vector(0 to 1);
begin
	sel <= (sel0, sel1);

	process (sel, a0, a1, a2, a3) is
	begin
		case sel is
			when "00" => y <= a0 after T_PD;
			when "01" => y <= a1 after T_PD;
			when "10" => y <= a2 after T_PD;
			when "11" => y <= a3 after T_PD;
		end case;
	end process;
end architecture behav;
\end{lstlisting}

Syntax of \emph{selected variable assignments} (VHDL-2008 only):
\begin{lstlisting}
[label_name:]
with expression select
variable := {value when expression,}
	value when expression;
\end{lstlisting}

\emph{Null} statements (no operation): \lstinline![label_name:] null;!.

General syntax of \emph{loops}:
\begin{lstlisting}
[label_name:]
[while expression                               -- Boolean expression
 | for identifier in bound1 (to|downto) bound2] -- Discrete range
loop                                            -- Loops forever without
                                                -- while or for
	{...}
end loop [label_name];
\end{lstlisting}

Loops can be aborted with the \lstinline!exit! statement: \lstinline![label_name:] exit [label_loop] [when expression];!, to continue with the next iteration of the loop one can use the \lstinline!next! statement:\\ \lstinline![label_name:] next [label_loop] [when expression];!.

Example of a loop without \lstinline!while! or \lstinline!for!:
\begin{lstlisting}
entity counter is
	port (clk   : in bit;
	      count : out natural);
end entity counter;

architecture behav of counter is
begin
	process is
		variable c : natural := 15;
	begin
		count <= c;
		loop
			wait until clk = '1';
			c := c - 1 when c /= 0
			     else 15;
			count <= c;
		end loop;
	end process;
end architecture behav;
\end{lstlisting}

Example of a \emph{for loop}:
\begin{lstlisting}
entity average is
	port (clk  : in bit;
	      din  : in real;
	      dout : out real);
end entity average;

architecture behav of average is
	constant N : integer := 4;
begin
	process is
		variable sum : real;
	begin
		loop
			sum := 0.0;
			for i in 0 to N-1 loop
				wait until clk = '1';
				sum := sum + din;
			end loop;

			dout <= sum / real(N);
		end loop;
	end process;
end architecture behav;
\end{lstlisting}

Syntax of \emph{assertions} (for simulation, synthesis or formal verification):
\begin{lstlisting}
[label_name:] assert expression
         [report expression] [severity level];

-- Valid values for level:
-- note, warning, error, failure
\end{lstlisting}

\emph{Report} statements are equivalent to unconditional assertions:\\ \lstinline![label_name:] report expression [severity level];!.
%
%
%
%
\subsection{Composite Data Types}
Declaring new \emph{array} types:
\begin{lstlisting}
type identifier is array
	(discrete_subtype                                   -- Index is a discrete
	                                                    -- subtype
	 | discrete_subtype range bound1 (to|downto) bound2 -- Index is a discrete
	                                                    -- subtype with
	                                                    -- constrained range
	 | bound1 (to|downto) bound2                        -- Index range is
	)                                                   -- specified directly
	 {, ...}                                            -- Multidimensional
	                                                    -- array
	) of subtype;
\end{lstlisting}

Example of a one-dimensional array:
\begin{lstlisting}
entity reg is
	port (din         : in bit_vector (31 downto 0);
	      read, write : in integer range 0 to 15;
	      wen         : in bit;
	      dout        : out bit_vector (31 downto 0));
end entity reg;

architecture behav of reg is
begin
	process (din, read, write, wen) is
		type mem is array (0 to 15) of bit_vector (31 downto 0);
		variable memory : mem;
	begin
		if wen = '1' then
			memory(write) := din;
		end if;
		dout <= memory(read);
	end process;
end architecture behav;
\end{lstlisting}

Array literals can be constructed out of scalar data types using \emph{array aggregates}:
\begin{lstlisting}
([expression                   -- Named association: indices explicitly
                               --                    specified
  | discrete_subtype
  | bound1 (to|downto) bound2
  | others => ]                -- Wildcard for any indices that haven't been
                               -- specified previously (must be last)
  expression                   -- Positional association is used
                               -- if the [... => ] part is left out
{, ...})
\end{lstlisting}

Example:
\begin{lstlisting}
type narray is array (0 to 3) of natural;

variable n1 : narray := (1, 2, 3, 4);     -- Positional association
variable n2 : narray := (0 => 1, 1 => 2,  -- Named association
                         2 => 3, 3 => 4);
\end{lstlisting}

Multiple indices can be separated with the ``\lstinline!|!'' character:
\begin{lstlisting}
type rarray is array (1 to 10) of real;

variable r : rarray := (1|2|4 => 3.14, 5 to 7 => 2.718, others => 0.0);
\end{lstlisting}

Array aggregates can also be used as the target in both variable and signal assignments:
\begin{lstlisting}
[label_name:] (identifier|array_aggregate) := expression;
[label_name:] (identifier|array_aggregate) <= expression;

-- Example:
variable a, b, c, d : bit;
variable x          : bit_vector (3 downto 0);

(a, b, c, d) := x;
\end{lstlisting}

In addition to just scalar types, VHDL-2008 also allows the use of sub-arrays in the specification of array aggregates.

Attributes that can be used in conjunction with array types are (\lstinline!A! denotes either an array type or object, the index \lstinline!j=1,2,...! which dimension the attribute shall refer to. If the parentheses are left out, \lstinline!j! defaults to one.):

\begin{tabular}{ll}
\toprule
	\textbf{Attribute} & \textbf{Description}\\
\midrule
	\lstinline!A'left(j)! & Leftmost index\\
	\lstinline!A'right(j)! & Rightmost index\\
	\lstinline!A'low(j)! & Lowest index\\
	\lstinline!A'high(j)! & Highest index\\
	\lstinline!A'range(j)! & Index range\\
	\lstinline!A'reverse_range(j)! & Reversed index range\\
	\lstinline!A'length(j)! & Length of index range\\
	\lstinline!A'ascending(j)! & \lstinline!True!: ascending range, \lstinline!false!: descending range\\
	\lstinline!A'element! & Subtype of the elements in \lstinline!A! (VHDL-2008 only)\\
\bottomrule
\end{tabular}

Array types that leave the index range(s) unspecified are called \emph{unconstrained} array types and can be declared in the following way:
\begin{lstlisting}
type identifier is array
	(type_name range <>
	{, ...})          -- Multidimensional array
) of subtype;
\end{lstlisting}

Example:
\begin{lstlisting}
package array_type is
	type int_array is array (natural range <>) of integer;
end package array_type;

use work.array_type.all;

entity max is
	port (din  : in int_array;
	      dout : out integer);
end entity max;

architecture behav of max is
begin
	process (din) is
		variable max : integer;
	begin
		assert din'length /= 0
			report "Array has zero length!"
			severity failure;

		max := din(din'left);
		for i in din'range loop
			if din(i) > max then
				max := din(i);
			end if;
			dout <= max;
		end loop;
	end process;
end architecture behav;
\end{lstlisting}

Predefined unconstrained array types include \lstinline!string! and \lstinline!bit_vector!, VHDL-2008 additionally provides \lstinline!boolean_vector!, \lstinline!integer_vector!, \lstinline!real_vector! and \lstinline!time_vector!.

Parts of an array can be referenced using \emph{array slices}: \lstinline!identifier (bound1 (to|downto) bound2)!.

Declaring new \emph{record} types:
\begin{lstlisting}
type identifier is record
	identifier {, ...} : type_name;
	{...}
end record [identifier];
\end{lstlisting}

Single members in a record type can be referred to using \emph{selected names}: \lstinline!identifier.record_member!.

Example:
\begin{lstlisting}
type coordinate is record
	x, y, z : real;
end record coordinate;

variable v1, v2 : coordinate;

v1.x = 1.0; v1.y = 2.0; v1.z = 3.0;
v2 = v1;
\end{lstlisting}

\emph{Record aggregates} can be constructed similarly to array aggregates:
\begin{lstlisting}
([expression     -- Named association: record members explicitly specified,
                 -- multiple choices may be separated with the '|' character
  | others => ]  -- Wildcard for any members that haven't been
                 -- specified previously (must be last)
  expression     -- Positional association is used
                 -- if the [... => ] part is left out
{, ...})
\end{lstlisting}

Example:
\begin{lstlisting}
v1 = (1.0, 2.0, 3.0);                -- Positional association
v1 = (x => 1.0, y => 2.0, z => 3.0); -- Named association
v2 = (others => 0.0);
\end{lstlisting}
%
%
%
%
\newpage
\subsection{Entities and Architectures, Behavioral and Structural Modeling}
Syntax of \emph{entity} declarations:
\begin{lstlisting}
entity identifier is
	[port (
		identifier : {, ...} : (in|out|buffer|inout) type_name
			[:= default_value]
		{; ...}
	);]

	-- Declarations common to all implementations
	{...}
end [entity] [identifier];
\end{lstlisting}

\lstinline!In! and \lstinline!out! ports are unidirectional, \lstinline!inout! ports are bidirectional and \lstinline!buffer! ports are \lstinline!out! ports that can be read internally (VHDL-2008 also allows reading \lstinline!out! ports).

Syntax of \emph{architectures}:
\begin{lstlisting}
architecture identifier of entity_name is
	-- Declarations
	{...}
begin
	-- Concurrent statements
	{...}
end [architecture] [identifier];
\end{lstlisting}

\emph{Signals} (internal connections within an architecture) are declared as follows:\\ \lstinline!signal identifier {, ...} : type_name [:= initial_value];!.

Syntax of \emph{signal assignments}:
\begin{lstlisting}
[label_name:]
identifier <=
	[transport                      -- Delay mechanism
	 | [reject expression] inertial]
	value [after expression] {, ...};
	| unaffected;
\end{lstlisting}
%
%
%
%
%\subsection{Miscellaneous}
\section{ED}
\subsection{Vector Analysis}
Identities involving vector products ($\vec a, \vec b, \vec c\in\mathbb{R}^3$, the wedge operator $\wedge$ denotes the vector product):
\begin{gather*}
	\vec a\cdot(\vec b\wedge\vec c) = \vec b\cdot(\vec c\wedge\vec a) = \vec c\cdot(\vec a\wedge\vec b)\\
	\vec a\cdot(\vec c\wedge\vec b) = \vec b\cdot(\vec a\wedge\vec c) = \vec c\cdot(\vec b\wedge\vec a)
\end{gather*}
\begin{gather*}
	\vec a\wedge(\vec b\wedge\vec c) = \vec b(\vec a\cdot\vec c) - \vec c(\vec a\cdot\vec b)\\
	(\vec a\wedge\vec b)\wedge\vec c = \vec b(\vec a\cdot\vec c) - \vec a(\vec b\cdot\vec c)
\end{gather*}

Definition of the \emph{nabla} (\emph{del}) operator:
\[
	\vec\nabla = \begin{bmatrix}\nicefrac{\partial}{\partial x}\\
	                            \nicefrac{\partial}{\partial y}\\
	                            \nicefrac{\partial}{\partial z}
	             \end{bmatrix}
\]

\emph{Gradient} of a scalar field $f$:
\[
	\grad(f) = \vec\nabla f = \begin{bmatrix}\nicefrac{\partial f}{\partial x}\\
	                                         \nicefrac{\partial f}{\partial y}\\
	                                         \nicefrac{\partial f}{\partial z}
	                          \end{bmatrix}
\]

\emph{Divergence} of a vector field $\vec F$:
\[
	\Div(\vec F) = \vec\nabla\cdot\vec F = \frac{\partial F_x}{\partial x}
	                                       + \frac{\partial F_y}{\partial y}
	                                       + \frac{\partial F_z}{\partial z}
\]

\emph{Curl} of a vector field $\vec F$:
\[
	\curl(\vec F) = \vec\nabla\wedge\vec F = \begin{vmatrix}\hat e_x & \hat e_y & \hat e_z\\
	                                                        \nicefrac{\partial}{\partial x} & \nicefrac{\partial}{\partial y} & \nicefrac{\partial}{\partial z}\\
	                                                        F_x & F_y & F_z
	                                         \end{vmatrix}
\]

Product rules for gradients ($f,g$: scalar fields; $\vec F,\vec G$: vector fields):
\begin{gather*}
	\vec\nabla(fg) = f(\vec\nabla g) + g(\vec\nabla f)\\
	\vec\nabla(\vec F\cdot\vec G) = \vec F\wedge(\vec\nabla\wedge\vec G) + \vec G\wedge(\vec\nabla\wedge\vec F)
	                               +(\vec F\cdot\vec\nabla)\vec G + (\vec G\cdot\vec\nabla)\vec F
\end{gather*}

Product rules for divergences ($f$: scalar field; $\vec F,\vec G$: vector fields):
\begin{gather*}
	\vec\nabla\cdot(f\vec G) = f(\vec\nabla\cdot\vec G) + \vec G\cdot(\vec\nabla f)\\
	\vec\nabla\cdot(\vec F\wedge\vec G) = \vec G\cdot(\vec\nabla\wedge\vec F) - \vec F\cdot(\vec\nabla\wedge\vec G)
\end{gather*}

Product rules for curls ($f$: scalar field; $\vec F,\vec G$: vector fields):
\begin{gather*}
	\vec\nabla\wedge(f\vec G) = f(\vec\nabla\wedge\vec G) - \vec G\wedge(\vec\nabla f)\\
	\vec\nabla\wedge(\vec F\wedge\vec G) = (\vec G\cdot\vec\nabla)\vec F - (\vec F\cdot\vec\nabla)\vec G+\vec F(\vec\nabla\cdot\vec G) - \vec G(\vec\nabla\cdot\vec F)
\end{gather*}

Definition of the \emph{Laplacian} ($f$: scalar field):
\[
	\vec\nabla\cdot(\vec\nabla f) = \vec\nabla^2 f = \Delta f = \frac{\partial^2 f}{\partial x^2} + \frac{\partial^2 f}{\partial y^2} + \frac{\partial^2 f}{\partial z^2}
\]

The curl of a gradient and the divergence of a curl always vanish:
\begin{gather*}
	\vec\nabla\wedge(\vec\nabla f)\equiv\vec 0\\
	\vec\nabla\cdot(\vec\nabla\wedge\vec F)\equiv 0
\end{gather*}

Curl of a curl:
\[
	\vec\nabla\wedge(\vec\nabla\wedge\vec F) = \vec\nabla(\vec\nabla\cdot\vec F) - \vec\nabla^2\vec F
\]

Fundamental theorem for gradients ($f$: scalar field):
\[
	\int_{\vec a}^{\vec b} (\vec\nabla f)\cdot\mathrm{d}\vec r = f(\vec b) - f(\vec a)
\]

\emph{Gauss's theorem} ($\vec F$: vector field):
\[
	\int_V(\vec\nabla\cdot\vec F)\,\mathrm{d}V = \oint_{\partial V}\vec F\cdot\mathrm{d}\vec a
\]

\emph{Stokes' theorem} ($\vec F$: vector field):
\[
	\int_S(\vec\nabla\wedge\vec F)\cdot\mathrm{d}\vec a = \oint_{\partial S}\vec F\cdot\mathrm{d}\vec r
\]

\emph{Spherical} coordinates:
\[
	\begin{bmatrix}x\\ y\\ z\end{bmatrix} =
	r\cdot\begin{bmatrix}\sin(\vartheta)\cdot\cos(\varphi)\\ \sin(\vartheta)\cdot\sin(\varphi)\\ \cos(\vartheta)\end{bmatrix}
\]

Unit vectors:
\begin{align*}
	\hat e_r &= \sin(\vartheta)\cdot\cos(\varphi)\cdot\hat e_x + \sin(\vartheta)\cdot\sin(\varphi)\cdot\hat e_y + \cos(\vartheta)\cdot\hat e_z\\
	\hat e_\vartheta &= \cos(\vartheta)\cdot\cos(\varphi)\cdot\hat e_x + \cos(\vartheta)\cdot\sin(\varphi)\cdot\hat e_y - \sin(\vartheta)\cdot\hat e_z\\
	\hat e_\varphi &= -\sin(\varphi)\cdot\hat e_x + \cos(\varphi)\cdot\hat e_y
\end{align*}

Line and volume elements:
\begin{align*}
	\mathrm{d}\vec r &= \mathrm{d}r\cdot\hat e_r + r\,\mathrm{d}\vartheta\cdot\hat e_\vartheta + r\sin(\vartheta)\,\mathrm{d}\varphi\cdot\hat e_\varphi\\
	\mathrm{d}V &= r^2\sin(\vartheta)\,\mathrm{d}r\,\mathrm{d}\vartheta\,\mathrm{d}\varphi
\end{align*}

Gradient:
\[
	\vec\nabla f = \frac{\partial f}{\partial r}\cdot\hat e_r + \frac{1}{r}\,\frac{\partial f}{\partial \vartheta}\cdot\hat e_\vartheta
	               + \frac{1}{r\sin(\vartheta)}\,\frac{\partial f}{\partial\varphi}\cdot\hat e_\varphi
\]

Divergence:
\[
	\vec\nabla\cdot\vec F = \frac{1}{r^2}\,\frac{\partial}{\partial r}(r^2\cdot F_r)
	                        + \frac{1}{r\sin(\vartheta)}\,\frac{\partial}{\partial\vartheta}\left(\sin(\vartheta)\cdot F_\vartheta\right)
	                        + \frac{1}{r\sin(\vartheta)}\,\frac{\partial}{\partial\varphi} F_\varphi
\]

Curl:
\begin{equation*}
\begin{split}
	\vec\nabla\wedge\vec F &= \frac{1}{r\sin(\vartheta)}\cdot\left[\frac{\partial}{\partial\vartheta}\left(\sin(\vartheta)\cdot F_\varphi\right)
	                    - \frac{\partial}{\partial\varphi}F_\vartheta\right]\cdot\hat e_r\\
	                 &\quad +\frac{1}{r}\cdot\left[\frac{1}{\sin(\vartheta)}\,\frac{\partial}{\partial\varphi}F_r
	                    - \frac{\partial}{\partial r}(r\cdot F_\varphi)\right]\cdot\hat e_\vartheta\\
	                 &\quad +\frac{1}{r}\cdot\left[\frac{\partial}{\partial r}(r\cdot F_\vartheta)-\frac{\partial}{\partial\vartheta}F_r\right]\cdot\hat e_\varphi
\end{split}
\end{equation*}

Laplacian:
\begin{equation*}
	\Delta f = \frac{1}{r^2}\,\frac{\partial}{\partial r}\left(r^2\cdot\frac{\partial f}{\partial r}\right)
	           + \frac{1}{r^2\sin(\vartheta)}\,\frac{\partial}{\partial\vartheta}\left(\sin(\vartheta)\cdot\frac{\partial f}{\partial\vartheta}\right)
	           + \frac{1}{r^2\sin^2(\vartheta)}\cdot\frac{\partial^2 f}{\partial\varphi^2}
\end{equation*}

\emph{Cylindrical} coordinates:
\[
	\begin{bmatrix}x\\ y\\ z\end{bmatrix} =
	\begin{bmatrix}\varrho\cdot\cos(\varphi)\\ \varrho\cdot\sin(\varphi)\\ z\end{bmatrix}
\]

Unit vectors:
\begin{align*}
	\hat e_\varrho &= \cos(\varphi)\cdot\hat e_x + \sin(\varphi)\cdot\hat e_y\\
	\hat e_\varphi &= -\sin(\varphi)\cdot\hat e_x + \cos(\varphi)\cdot\hat e_y\\
	\hat e_z &= \hat e_z
\end{align*}

Line and volume elements:
\begin{align*}
	\mathrm{d}\vec r &= \mathrm{d}\varrho\cdot\hat e_\varrho + \varrho\,\mathrm{d}\varphi\cdot\hat e_\varphi + \mathrm{d}z\cdot\hat e_z\\
	\mathrm{d}V &= \varrho\,\mathrm{d}\varrho\,\mathrm{d}\varphi\,\mathrm{d}z
\end{align*}

Gradient:
\[
	\vec\nabla f = \frac{\partial f}{\partial\varrho}\cdot\hat e_\varrho + \frac{1}{\varrho}\,\frac{\partial f}{\partial\varphi}\cdot\hat e_\varphi
	               + \frac{\partial f}{\partial z}\cdot\hat e_z
\]

Divergence:
\[
	\vec\nabla\cdot\vec F = \frac{1}{\varrho}\,\frac{\partial}{\partial\varrho}(\varrho\cdot F_\varrho)
	                        + \frac{1}{\varrho}\,\frac{\partial}{\partial\varphi}\cdot F_\varphi + \frac{\partial}{\partial z}\cdot F_z
\]

Curl:
\begin{equation*}
\begin{split}
	\vec\nabla\wedge\vec F &= \left(\frac{1}{\varrho}\,\frac{\partial}{\partial\varphi}\cdot F_z-\frac{\partial}{\partial z}\cdot F_\varphi\right)\cdot\hat e_\varrho\\
	                       &\quad+ \left(\frac{\partial}{\partial z}F_\varrho-\frac{\partial}{\partial\varrho}\cdot F_z\right)\cdot\hat e_\varphi\\
	                       &\quad+ \frac{1}{\varrho}\cdot\left[\frac{\partial}{\partial\varrho}(\varrho\cdot F_\varphi)-\frac{\partial}{\partial\varphi}\cdot
	                               F_\varrho\right]\cdot\hat e_z
\end{split}
\end{equation*}

Laplacian:
\[
	\Delta f = \frac{1}{\varrho}\,\frac{\partial}{\partial\varrho}\left(\varrho\cdot\frac{\partial f}{\partial\varrho}\right)
	           + \frac{1}{\varrho^2}\cdot\frac{\partial^2 f}{\partial\varphi^2} + \frac{\partial^2 f}{\partial z^2}
\]

\emph{Delta distribution} (differentiation with respect to $\vec r$, $\vec r'\equiv\text{const.}$):
\begin{gather*}
	\vec\nabla\cdot\left(\frac{\vec r-\vec r'}{|\vec r-\vec r'|^3}\right) = 4\pi\cdot\delta^{(3)}(\vec r-\vec r')\\
	\Delta\left(\frac{1}{|\vec r-\vec r'|}\right) = -4\pi\cdot\delta^{(3)}(\vec r-\vec r')
\end{gather*}

Properties of \emph{curl-less} fields:
\begin{enumerate}
	\item $\vec\nabla\wedge\vec F\equiv\vec 0$
	\item $\int_\gamma\vec F\cdot\mathrm{d}\vec r$ is independent of the path $\gamma$
	\item $\oint_\gamma\vec F\cdot\mathrm{d}\vec r\equiv 0\quad\forall\gamma$
	\item $\vec F=-\vec\nabla \phi\quad$ ($\phi$: scalar potential)
\end{enumerate}

Properties of \emph{divergence-less} field:
\begin{enumerate}
	\item $\vec\nabla\cdot\vec F\equiv 0$
	\item $\int_S\vec F\cdot\mathrm{d}\vec a$ is independent of the surface $S$
	\item $\oint_S\vec F\cdot\mathrm{d}\vec a\equiv 0\quad\forall S$
	\item $\vec F=\vec\nabla\wedge\vec A\quad$ ($\vec A$: vector potential)
\end{enumerate}
%
%
%
%
\subsection{Electrostatics}
\emph{Coulomb's law} (force on a test charge $Q$ caused by a point charge $q$ at location $\vec r'$,\\ $\varepsilon_0$: permittivity of free space):
\[
	\vec F(\vec r) = \frac{qQ}{4\pi\varepsilon_0}\cdot\frac{\vec r-\vec r'}{|\vec r-\vec r'|^3}
\]

Force on a test charge exerted by several point charges $q_1,\dots,q_n$:
\[
	\vec F = Q\cdot\vec E
\]

\emph{Electric field}:
\[
	\vec E(\vec r) = \frac{1}{4\pi\varepsilon_0}\cdot\sum_{j=1}^n q_j\cdot\frac{\vec r-\vec r_j}{|\vec r-\vec r_j|^3}
\]

Electric field generated by the charge distribution $\varrho(\vec r)$:
\[
	\vec E(\vec r) = \frac{1}{4\pi\varepsilon_0}\cdot\int\varrho(\vec r')\cdot\frac{\vec r-\vec r'}{|\vec r-\vec r'|^3}\,\mathrm{d}^3 r'
\]

\emph{Electric flux} through a surface $S$:
\[
	\Phi = \int_S\vec E\cdot\mathrm{d}\vec a
\]

\emph{Gauss's law} (differential form):
\begin{equation*}
\begin{split}
	\vec\nabla\cdot\vec E &= \frac{1}{4\pi\varepsilon_0}\cdot\int\mathrm{d}^3 r'\,\varrho(\vec r')\,\vec\nabla\cdot\left(\frac{\vec r-\vec r'}{|\vec r-\vec r'|^3}\right)
	                         = \frac{1}{4\pi\varepsilon_0}\cdot\int\mathrm{d}^3 r'\,\varrho(\vec r')\,4\pi\cdot\delta^{(3)}(\vec r-\vec r')\\
	                      &= \frac{1}{\varepsilon_0}\cdot\varrho(\vec r)
\end{split}
\end{equation*}

Gauss's law (integral form):
\begin{equation*}
\begin{split}
	\oint_{\partial V}\vec E\cdot\mathrm{d}\vec a &= \int_V\vec\nabla\cdot\vec E\,\mathrm{d}V = \frac{1}{\varepsilon_0}\cdot\int_V\varrho(\vec r)\,\mathrm{d}V\\
	                                              &= \frac{1}{\varepsilon_0}\cdot Q_\mathrm{total}
\end{split}
\end{equation*}

Closed paths, curl of an electric field:
\begin{gather*}
		\oint_\gamma\vec E\cdot\mathrm{d}\vec r\equiv 0\quad\forall\gamma\\
		\vec\nabla\wedge\vec E\equiv\vec 0
\end{gather*}

Definition of the electric potential ($\vec r_\mathrm{ref}$: reference point):
\begin{equation*}
	\phi(\vec r)=-\int_{\vec r_\mathrm{ref}}^{\vec r}\vec E(\vec r')\cdot\mathrm{d}\vec r'\,\curvearrowright\,\vec E(\vec r)=-\vec\nabla\phi(\vec r)
\end{equation*}

Poisson's equation:
\[
	\vec\nabla^2\phi=\Delta\phi=-\frac{\varrho}{\varepsilon_0}
\]

Laplace's equation ($\varrho\equiv 0$):
\[
	\vec\nabla^2\phi=\Delta\phi=0
\]

Potential of a charge distribution ($\vec r_\mathrm{ref}\to\infty$):
\[
	\phi(\vec r)=\frac{1}{4\pi\varepsilon_0}\cdot\int\frac{\varrho(\vec r')}{|\vec r-\vec r'|}\,\mathrm{d}^3 r'
\]

Energy stored in an electric field:
\[
	W=\frac{\varepsilon_0}{2}\cdot\int_{\mathbb{R}^3}\vec E^2\,\mathrm{d}V
\]

Properties of an ideal conductor:
\begin{enumerate}
	\item $\vec E\equiv\vec 0$ on the inside
	\item $\varrho\equiv 0$ on the inside
	\item Any net charge resides on the surface.
	\item $\phi(\vec r)\equiv\text{const.}$
	\item $\vec E\perp \text{surface}$
\end{enumerate}

Boundary conditions at the proximity of a surface with surface charge density $\sigma$ ($\hat n$: unit vector perpendicular to the surface):
\[
	\vec E_\mathrm{above}-\vec E_\mathrm{below}=\frac{\sigma}{\varepsilon_0}\cdot\hat n
\]

Multipole expansion in cartesian coordinates ($P_n$: Legendre polynomials, $\alpha:=\angle\left(\vec r,\vec r'\right)$):
\[
	\phi(\vec r)=\frac{1}{4\pi\varepsilon_0}\cdot\sum_{n=0}^\infty\frac{1}{|\vec r|^{n+1}}\,\int|\vec r'|^n\,P_n\left(\cos(\alpha)\right)\,\varrho(\vec r')\,\mathrm{d}^3 r'
\]

Dipole moments:
\begin{gather*}
	\vec p=\int\vec r'\,\varrho(\vec r')\,\mathrm{d}^3 r'\\
	\phi^{(2)}(\vec r)=\frac{1}{4\pi\varepsilon_0}\cdot\frac{\vec p\cdot\hat e_r}{|\vec r|^2}
\end{gather*}
%
%
%
%
\subsection{Electric fields in matter}
Polarization:
\[
	\vec P=\frac{\text{dipole moment}}{\text{unit volume}}
\]

Electric displacement:
\begin{gather*}
	\vec D=\varepsilon_0\,\vec E+\vec P\\
	\vec\nabla\wedge\vec D=\varepsilon_0\,(\vec\nabla\wedge\vec E)+\vec\nabla\wedge\vec P=
		\vec\nabla\wedge\vec P\neq\vec 0
\end{gather*}

Gauss's law ($\varrho_\mathrm{f}$: free charge density):
\begin{gather*}
	\vec\nabla\cdot\vec D = \varrho_\mathrm{f}\\
	\oint_{\partial V}\vec D\cdot\mathrm{d}\vec a = Q_\mathrm{total}
\end{gather*}

Boundary conditions ($\sigma_\mathrm{f}$: free surface charge density):
\begin{gather*}
	D_\text{above}^\perp -D_\text{below}^\perp = \sigma_\mathrm{f}\\
	D_\text{above}^\parallel - D_\text{below}^\parallel = P_\text{above}^\parallel - P_\text{below}^\parallel
\end{gather*}

Polarization in linear dielectrics ($\chi_\mathrm{e}$: electric susceptibility):
\[
	\vec P=\varepsilon_0\chi_\mathrm{e}\,\vec E
\]

Permittivity:
\[
	\varepsilon=\varepsilon_0\,(1+\chi_\mathrm{e})
\]

Electric displacement:
\[
	\vec D=\varepsilon\,\vec E
\]

Dielectric constant:
\[
	\varepsilon_\mathrm{r} = 1+\chi_\mathrm{e}=\frac{\varepsilon}{\varepsilon_0}
\]
%
%
%
%
%
\section{QM}
Schroedinger equation in one dimension:
\[
	\mathrm{i}\hbar\,\frac{\partial\Psi}{\partial t}=-\frac{\hbar^2}{2m}\,\frac{\partial^2\Psi}{\partial x^2}+V\cdot\Psi
\]

Statistical interpretation:
\[
	P(a\le x\le b; t)=\int_a^b |\Psi(x,t)|^2\,\mathrm{d}x
\]

Expectation value ($\varrho$: probability density):
\[
	\langle f(x)\rangle=\int_{-\infty}^\infty f(x)\cdot\varrho(x)\,\mathrm{d}x
\]

Variance:
\begin{gather*}
	\sigma^2\equiv\langle\left(x-\langle x\rangle\right)^2\rangle\\
	\sigma^2=\langle x^2\rangle - \langle x\rangle^2
\end{gather*}

Normalization requirement:
\[
	\int_{-\infty}^\infty |\Psi(x,t)|^2\,\mathrm{d}x = 1
\]

Uncertainty principle:
\[
	\sigma_x\,\sigma_p\ge\frac{\hbar}{2}
\]

Hamiltonian ($p\to\frac{\hbar}{\mathrm{i}}\,\frac{\partial}{\partial x}$):
\[
	H=\frac{p^2}{2m}+V(x)=-\frac{\hbar^2}{2m}\,\frac{\partial^2}{\partial x^2}+V(x)
\]

Time-independent Schroedinger equation:
\[
	H\psi(x)=E\psi(x)
\]

General solution of the separable time-dependent Schroedinger equation:
\[
	\Psi(x,t)=\sum_{n=1}^\infty c_n\cdot\psi_n(x)\cdot\mathrm{e}^{-\mathrm{i} E_n\cdot t/\hbar}
\]

1D infinite square well:
\begin{gather*}
	V(x)=\begin{cases}
		0, & 0\le x\le a\\
		\infty, & \text{otherwise}
	\end{cases}\\
	E_n = \frac{n^2\pi^2\hbar^2}{2ma^2}, \quad n=1,2,\dots\\
	\psi_n = \sqrt{\frac{2}{a}}\cdot\sin\left(\frac{n\pi}{a}\cdot x\right)
\end{gather*}

Hermite polynomials (Rodrigues formula):
\[
	H_n(\xi)=(-1)^n\cdot\mathrm{e}^{\xi^2}\cdot\left(\frac{\mathrm{d}}{\mathrm{d}\xi}\right)^n\,\mathrm{e}^{-\xi^2}
\]

1D harmonic oscillator ($\xi\equiv\sqrt{\frac{m\omega}{\hbar}}\cdot x$, $H_n$: Hermite polynomials):
\begin{gather*}
	V(x) = \frac{1}{2} m\omega^2 x^2\\
	E_n = \left(n+\frac{1}{2}\right)\cdot\hbar\omega\quad n=0,1,2,\dots\\
	\psi_n(x) = \left(\frac{m\omega}{\pi\hbar}\right)^{\nicefrac{1}{4}}\cdot\frac{1}{\sqrt{2^n n!}}\cdot
		H_n(\xi)\cdot\mathrm{e}^{-\xi^2/2}
\end{gather*}

Free particle ($k\equiv\pm\frac{\sqrt{2mE}}{\hbar}$, dispersion relation: $\omega=\frac{\hbar k^2}{2m}$):
\begin{gather*}
	\Psi(x,t)=\frac{1}{\sqrt{2\pi}}\cdot\int_{-\infty}^\infty \phi(k)\cdot
		\mathrm{e}^{\mathrm{i}\left(kx-\frac{\hbar k^2}{2m}\cdot t\right)}\,\mathrm{d}k
		=\frac{1}{\sqrt{2\pi}}\cdot\int_{-\infty}^\infty \phi(k)\cdot
		\mathrm{e}^{\mathrm{i}(kx-\omega t)}\\
	\phi(k)=\frac{1}{\sqrt{2\pi}}\cdot\int_{-\infty}^\infty \Psi(x,0)\cdot
		\mathrm{e}^{-\mathrm{i}kx}\,\mathrm{d}x
\end{gather*}

Group velocity:
\[
	v_\mathrm{g}=\frac{\mathrm{d}\omega}{\mathrm{d}k}
\]

Phase velocity:
\[
	v_\mathrm{ph}=\frac{\omega}{k}
\]

Definition of bound and scattering states ($V(x\to\infty)=0$):
\begin{itemize}
	\item $E<0$: bound state
	\item $E>0$: scattering state
\end{itemize}

Delta function potential:
\begin{equation*}
	V(x)=-\alpha\delta(x)
\end{equation*}

Bound state:
\begin{gather*}
	\psi(x)=\frac{\sqrt{m\alpha}}{\hbar}\cdot\mathrm{e}^{-m\alpha|x|/\hbar^2}\\
	E=-\frac{m\alpha^2}{2\hbar^2}
\end{gather*}

Inner product:
\begin{gather*}
	\braket{\alpha|\beta}=a_1^* b_1 + a_2^* b_2 + \dots + a_N^* b_N\\
	\braket{\beta|\alpha}=\braket{\alpha|\beta}^*\\
	\braket{f|g}=\int_a^b f(x)^* g(x)\,\mathrm{d}x
\end{gather*}

Schwarz inequality:
\[
	\left|\braket{f|g}\right| \le \sqrt{\braket{f|f}\cdot\braket{g|g}}
\]

Orthonormal set of functions $\{f_n\}$:
\[
	\braket{f_m|f_n} = \delta_{mn}
\]

Complete set of functions $\{f_n\}$:
\begin{gather*}
	f(x)=\sum_{n=1}^\infty c_n\cdot f_n(x)\\
	c_n=\braket{f_n|f}
\end{gather*}

Expectation value of an observable:
\[
	\langle Q\rangle=\int \psi^*\hat Q\psi\,\mathrm{d}x=\braket{\psi|\hat Q|\psi}
\]

Hermitian operators:
\[
	\braket{f|\hat Q f}=\braket{\hat Qf|f}
\]

Properties of eigenfunctions of hermitian operators $\hat Q$ with discrete spectra:
\begin{enumerate}
	\item $\hat Q f=qf\,\curvearrowright\,q\in\mathbb{R}$
	\item $\hat Q f=qf,\,\, \hat Q g=q'g,\,\,q\neq q'\,\curvearrowright\,\braket{f|g}=0$
\end{enumerate}

Momentum space wave function:
\begin{gather*}
	\Phi(p,t)=\frac{1}{\sqrt{2\pi\hbar}}\cdot\int_{-\infty}^\infty \mathrm{e}^{-\mathrm{i}px/\hbar}
		\cdot\Psi(x, t)\,\mathrm{d}x\\
	\Psi(x,t)=\frac{1}{\sqrt{2\pi\hbar}}\cdot\int_{-\infty}^\infty \mathrm{e}^{\mathrm{i}px/\hbar}
		\cdot\Phi(p,t)\,\mathrm{d}p
\end{gather*}

Commutator of two operators $\hat A, \hat B$:
\[
	[\hat A, \hat B]:=\hat A\hat B - \hat B\hat A
\]

Anticommutator of two operators $\hat A, \hat B$:
\[
	\{\hat A, \hat B\}:=\hat A\hat B + \hat B\hat A
\]

Generalized uncertainty principle (observable $A$: $\sigma_A^2=\braket{\left(\hat A-\langle A\rangle\right)\Psi|\left(\hat A-\langle A\rangle\right)\Psi}$,\\ observable $B$: $\sigma_B^2=\braket{\left(\hat B-\langle B\rangle\right)\Psi|\left(\hat B-\langle B\rangle\right)\Psi}$):
\[
	\sigma_A^2\sigma_B^2\ge\left(\frac{1}{2\mathrm{i}} \langle [\hat A,\hat B]\rangle\right)^2
\]

Time dependence of an expectation value ($Q$: observable, $H$: Hamiltonian):
\begin{gather*}
	\frac{\mathrm{d}}{\mathrm{d}t}\langle Q\rangle=
		\frac{\mathrm{i}}{\hbar}\langle[\hat H,\hat Q]\rangle+\langle\frac{\partial\hat Q}{\partial t}\rangle
\end{gather*}

Schroedinger equation in three dimensions ($\vec p\to\frac{\hbar}{\mathrm{i}}\vec\nabla$):
\[
	\mathrm{i}\hbar\frac{\partial\Psi}{\partial t}=-\frac{\hbar^2}{2m}\Delta\Psi + V\Psi
\]

Normalization requirement:
\[
	\int_{\mathbb{R}^3}|\Psi|^2\,\mathrm{d}V=1
\]

Probability current and conservation of probability:
\begin{gather*}
	\vec j=\frac{\mathrm{i}\hbar}{2m}\cdot(\Psi\vec\nabla\Psi^* - \Psi^* \vec\nabla\Psi)\\
	\vec\nabla\cdot\vec j=-\frac{\partial}{\partial t}|\Psi|^2
\end{gather*}

Time-independent Schroedinger equation:
\[
	-\frac{\hbar^2}{2m}\Delta\psi + V\psi=E\psi
\]

General solution of the separable time-dependent Schroedinger equation:
\[
	\Psi(\vec r,t)=\sum_{n=1}^\infty c_n\psi_n(\vec r)\cdot\mathrm{e}^{-\mathrm{i}E_n\cdot t/\hbar}
\]

Canonical commutation relations ($i,j\in\{1,2,3\}$):
\begin{gather*}
	[r_i,p_j]=\mathrm{i}\hbar\delta_{ij}\\
	[r_i,r_j]=[p_i,p_j]=0
\end{gather*}

Legendre polynomials (Rodrigues formula):
\[
	P_l(x)=\frac{1}{2^l l!}\cdot\left(\frac{\mathrm{d}}{\mathrm{d}x}\right)^l \cdot(x^2-1)^l
\]

Associated Legendre functions:
\[
	P_l^m(x)=(1-x^2)^{|m|/2}\cdot\left(\frac{\mathrm{d}}{\mathrm{d}x}\right)^{|m|}\cdot P_l(x)
\]

Spherical harmonics (normalized angular wave function):
\begin{gather*}
	\text{Azimuthal quantum number: } l=0,1,2,\dots\\
	\text{Magnetic quantum number: } m=-l,\,-l+1,\,\dots,\,l-1,\,l\\
	Y_l^m(\vartheta,\varphi)=\sqrt{\frac{2l+1}{4\pi}\cdot\frac{(l-|m|)!}{(l+|m|)!}}
		\cdot\mathrm{e}^{\mathrm{i}m\varphi}\cdot P_l^m\left(\cos(\vartheta)\right)
		\cdot\begin{cases}(-1)^m, &m\ge 0\\ 1, &m<0\end{cases}
\end{gather*}

Orthonormality:
\[
	\int_0^{2\pi}\mathrm{d}\varphi\,\int_0^\pi\mathrm{d}\vartheta\,\sin(\vartheta)\,
		Y_l^m(\vartheta,\varphi)^*\cdot Y_{l'}^{m'}(\vartheta,\varphi)=\delta_{ll'}\delta_{mm'}
\]

Radial equation ($\psi(r,\vartheta,\varphi)=R(r)\cdot Y(\vartheta,\varphi)$, $u(r)\equiv r\cdot R(r)$):
\[
	-\frac{\hbar^2}{2m}\cdot\frac{\mathrm{d}^2 u}{\mathrm{d}r^2}
		+ \underbrace{\left[V+\frac{\hbar^2}{2m}\cdot\frac{l(l+1)}{r^2}\right]}_\text{effective potential}\cdot u = E\cdot u
\]

Radial wave equation for the hydrogen atom:
\[
	-\frac{\hbar^2}{2m_\mathrm{e}}\cdot\frac{\mathrm{d}^2 u}{\mathrm{d}r^2}
		+\left[-\frac{e^2}{4\pi\varepsilon_0}\cdot\frac{1}{r}+\frac{\hbar^2}{2}\cdot\frac{l(l+1)}{r^2}\right]\cdot u=E\cdot u
\]

Laguerre polynomial:
\[
	L_q(x)=\mathrm{e}^x\cdot\left(\frac{\mathrm{d}}{\mathrm{d}x}\right)^q\,\left(\mathrm{e}^{-x}\cdot x^q\right)
\]

Associated Laguerre polynomial:
\[
	L_{q-p}^p(x)=(-1)^p\cdot\left(\frac{\mathrm{d}}{\mathrm{d}x}\right)^p\,L_q(x)
\]

Energies (degeneracy of $E_n$: $n^2$):
\[
	E_n=-\left[\frac{m_\mathrm{e}}{2\hbar ^2}\cdot\left(\frac{e^2}{4\pi\varepsilon_0}\right)\right]\cdot\frac{1}{n^2},\quad n=1,2,\dots
\]

Bohr radius:
\[
	a_\mathrm{B}=\frac{4\pi\varepsilon_0\hbar^2}{m_\mathrm{e}e^2}
\]

Hydrogen wave function:
\begin{gather*}
	\psi_{nlm}(r,\vartheta,\varphi)=
		\sqrt{\left(\frac{2}{na}\right)^3\cdot\frac{(n-l-1)!}{2n\left[(n+l)!\right]^3}}
		\cdot\mathrm{e}^{-\nicefrac{r}{na}}\cdot\left(\frac{2r}{na}\right)^l
		\cdot\left[L_{n-l-1}^{2l+1}\left(\nicefrac{2r}{na}\right)\right]\cdot Y_l^m(\vartheta,\varphi)\\
	n=1,2,3,\,\dots;\,\,l=0,1,2,\,\dots,\,n-1;\,\,m=-l,\,-l+1,\,\dots,\,l-1,\,l
\end{gather*}

Angular momentum operator:
\[
	\hat{\vec L}=\hat{\vec r}\wedge\left(\frac{\mathrm{i}}{\hbar}\vec\nabla\right)
\]

Commutation relations ($L^2\equiv L_x^2+L_y^2+L_z^2$):
\begin{gather*}
	[L_x,L_y]=\mathrm{i}\hbar L_z;
		\quad[L_y,L_z]=\mathrm{i}\hbar L_x;
		\quad[L_z,L_x]=\mathrm{i}\hbar L_y\\
	[L^2,\vec L]=0
\end{gather*}

Eigenvalues ($Y_l^m$: spherical harmonics):
\begin{gather*}
	L^2\, Y_l^m=\hbar^2l(l+1)\,Y_l^m;\quad
		L_z\,Y_l^m=\hbar m\,Y_l^m\\
	l=0,\,\nicefrac{1}{2},\,1,\,\nicefrac{3}{2},\,\dots;\quad
		m=-l,-l+1,\dots,l-1,l
\end{gather*}

Commutation relations for spin:
\[
	[S_x,S_y]=\mathrm{i}\hbar S_z;
		\quad[S_y,S_z]=\mathrm{i}\hbar S_x;
		\quad[S_z,S_x]=\mathrm{i}\hbar S_y
\]

Eigenvectors and eigenvalues of $S^2$ and $S_z$:
\begin{gather*}
	S^2\ket{s\,m}=\hbar^2s(s+1)\,\ket{s\,m};
		\quad S_z\,\ket{s\,m}=\hbar m\ket{s\,m}\\
	s=0,\,\nicefrac{1}{2},\,1,\,\nicefrac{3}{2},\,\dots;
		\quad m=-s,-s+1,\dots,s-1,s
\end{gather*}

Eigenstates of spin $\nicefrac{1}{2}$ ($s=\nicefrac{1}{2}$):
\begin{itemize}
	\item Spin up: $\ket{\frac{1}{2}\,\frac{1}{2}} = \ket{\frac{1}{2}\,\uparrow}$
	\item Spin down: $\ket{\frac{1}{2}\,\left(-\frac{1}{2}\right)} = \ket{\frac{1}{2}\,\downarrow}$
\end{itemize}

Spinor:
\begin{gather*}
	\chi=\begin{bmatrix}a\\b\end{bmatrix}=a\chi_+ + b\chi_-\\
	\chi_+=\begin{bmatrix}1\\0\end{bmatrix},\,
	\chi_-=\begin{bmatrix}0\\1\end{bmatrix}\\
	|a|^2+|b|^2=1
\end{gather*}

Pauli matrices:
\[
	\sigma_x=\begin{bmatrix}0 & 1\\ 1 & 0\end{bmatrix},
	\quad\sigma_y=\begin{bmatrix}0 & -\mathrm{i}\\ \mathrm{i} & 0\end{bmatrix},
	\quad\sigma_z=\begin{bmatrix}1 & 0\\ 0 & -1\end{bmatrix}
\]

Spin operator ($\vec\sigma=[\sigma_x,\sigma_y,\sigma_z]$):
\[
	\vec S = \frac{\hbar}{2}\cdot\vec\sigma
\]

Hamiltonian of a charged particle at rest in a magnetic field ($\gamma$: gyromagnetic ratio):
\[
	H=-\gamma\vec B\cdot\vec S
\]

Triplet states ($s=1$):
\begin{enumerate}
	\item $\ket{1\,1} = \,\uparrow\,\uparrow$
	\item $\ket{1\,0} = \frac{1}{\sqrt{2}}\left(\uparrow\,\downarrow+\downarrow\,\uparrow\right)$
	\item $\ket{1\,(-1)} = \,\downarrow\,\downarrow$
\end{enumerate}

Singlet state ($s=0$):
\[
	\ket{0\,0} = \frac{1}{\sqrt{2}}\left(\uparrow\,\downarrow-\downarrow\,\uparrow\right)
\]

Addition of spins $s_1$ and $s_2$:
\[
	s=(s_1+s_2),\,(s1+s_2-1),\,(s1+s2-2),\dots,|s_1-s_2|
\]

Combined states ($C_{m_1 m_2 m}^{s_1 s_2 s}$: Clebsch-Gordan coefficients):
\begin{gather*}
	\ket{s\,m}=\sum_{m_1+m_2=m} C_{m_1 m_2 m}^{s_1 s_2 s}\cdot\ket{s_1\,m_1}\,\ket{s_2\,m_2}\\
	\ket{s_1\,m_1}\,\ket{s_2\,m_2}=\sum_s C_{m_1 m_2 m}^{s_1 s_2 s}\cdot\ket{s\,m}
\end{gather*}

Symmetrization requirement (``$+$'': bosons, ``$-$'': fermions):
\[
	\psi(\vec r_1,\vec r_2)=\pm\psi(\vec r_2,\vec r_1)
\]
\end{document}
