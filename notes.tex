\documentclass[fontsize=11pt,a4paper]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{amsmath, amssymb, amsopn}
\usepackage{xcolor} % include before tikz!
\usepackage{tikz}
\usepackage[european]{circuitikz}
\usepackage{nicefrac}
\usepackage{trfsigns} % for \laplace,\Laplace
\usepackage{booktabs}
%\usepackage{framed}
%\usepackage{geometry}
%\geometry{left=0.5cm,right=0.5cm,top=0.5cm,bottom=0.5cm}
\setlength{\parskip}{7pt}
\setlength{\parindent}{0em}
%
%
%
\usepackage[osf]{libertine}
\usepackage{zi4}
\usepackage[libertine,cmbraces]{newtxmath}
%
%
%
%
\DeclareMathOperator{\grad}{grad}
\DeclareMathOperator{\Div}{div}
\DeclareMathOperator{\rot}{rot}
\DeclareMathOperator{\sinc}{sinc}
%
%
%
%
\usepackage{listings}
%\usepackage{bytefield}
%
%
%
%
\begin{document}
\clearpage
\begingroup
	\pagestyle{empty}
	\begin{center}
		\LARGE{\textbf{Notes}}
	\end{center}
	\hfill
	\tableofcontents
	\clearpage
\endgroup
\newpage
\setcounter{page}{1}
%
%
%
%
\lstset{numbers=left,
	frame=single,
	numberstyle=\tiny,
	basicstyle=\footnotesize,
	showstringspaces=false,
	%keywordstyle=\color{blue},
	%commentstyle=\em\color{gray},
	tabsize=3,
	numbersep=5pt,
	%morecomment=[s][\color{blue}]{<<<}{>>>},
	%morekeywords={float3,float4,__device__,__global__,__shared__,__constant__,threadIdx,blockIdx,blockDim,gridDim,\_\_syncthreads}}
}
%
%
%
\section{Verilog}
\subsection{Synthesis}
\lstset{language=verilog}
Listing \ref{lst:basic_structure} shows the basic structure of a Verilog module. Identifiers are case-sensitive.
\begin{figure}[htb]
\begin{lstlisting}
// Single line comment
/* Comment spanning
   several lines */

module some_module (
	// Ports
	input [wire/reg] in1,
	input in2,
	output [wire/reg] out
);
	// Internal signals
	wire signal1, signal2;

	// Vector, bus (32 bits wide)
	wire [31:0] bus;

	// Examples for accessing part of a vector:
	// bus[0], bus[7:0]

	// Local parameter, cannot be changed
	localparam PARAM = 42;

endmodule
\end{lstlisting}
\caption{Basic structure of a Verilog module}
\label{lst:basic_structure}
\end{figure}

Signals can take the values \lstinline!0! (logic $0$), \lstinline!1! (logic $1$), \lstinline!x! (undefined, uninitialized) and \lstinline!z! (high impedance).

Integer constants: \lstinline!<bits>'<base><literal>! (leaving out \lstinline!<bits>! defaults to a width of at least 32 bits, underscores in \lstinline!<literal>! are ignored). Valid values for \lstinline!<base>!: \lstinline!b! (binary), \lstinline!d! (decimal), \lstinline!o! (octal) and \lstinline!h! (hexadecimal). Examples: \lstinline!4'b01_01!, \lstinline!8'hab!, \lstinline!10!.

Instantiating modules or primitives connecting ports by sequence:
\begin{lstlisting}
some_module instance_name (
	// Inputs and outputs in the same order
	// as the appear in the declaration of some_module
	in1,
	in2,
	out
);
\end{lstlisting}

Connecting the ports by name:
\begin{lstlisting}
some_module instance_name (
	.IN1(in1),
	.IN2(in2),
	.OUT(out)
);
\end{lstlisting}

Dataflow modeling (combinatorial circuit)
\begin{lstlisting}
module my_xor (
	input a,
	input b,
	output y
);

	assign y = a ^ b;

endmodule
\end{lstlisting}

Operators
\begin{table}[htb]
	\centering
	\begin{tabular}{lll}
	\toprule
		\textbf{Operator} & \textbf{Type} & \textbf{Meaning} \\
	\midrule
		\lstinline!&! & Bitwise & AND \\
		\lstinline!|! & Bitwise & OR \\
		\lstinline!^! & Bitwise & Exclusive OR \\
		\lstinline!~! & Bitwise & One's complement \\
		\lstinline!{a, b, c}! & Other & Concatenate wires or vectores \\
		... & ... & ...\\
	\bottomrule
	\end{tabular}
	\caption{Verilog operators}
	\label{tab:operators}
\end{table}

Behavioral modeling using \lstinline!always! blocks:
\begin{lstlisting}
// Synchronous logic
// Edge triggered
always @(posedge clock, negedge reset) begin
	if (reset)
		counter <= 0;
	else
		counter <= counter + 1;
end

// Asynchronous logic
// Sensitive to all signals in block, level triggered
always @* begin
	// ...
end
\end{lstlisting}

Non-blocking assignment: \lstinline!signal <= /* ... */!

Blocking assignment: \lstinline!signal = /* ... */!

Switch case
\begin{lstlisting}
case (signal)
	value1: /* instruction / block */
	value2: /* instruction / block */
	// ...
	default: /* instruction / block */
endcase
\end{lstlisting}

\lstinline!casez! treats \lstinline!z!, \lstinline!casex! \lstinline!x! and \lstinline!z! as don't care values.

Use default values to avoid inference of latches/ registers.

Modeling of memory with arrays:
\begin{lstlisting}
// 256 bytes of memory
reg [7:0] mem [0:255];
//    ^         ^
//    |         |
//    |         -- Number of cells
//    ------------ Memory width
\end{lstlisting}

Tristate ports: \lstinline!inout!, Pull-down: \lstinline!tri0!, Pull-up: \lstinline!tri1!, Wired-AND: \lstinline!wand! or \lstinline!triand!, Wired-OR: \lstinline!wor! or \lstinline!trior!

Declaration and instantiation of modules with parameters:
\begin{lstlisting}
module some_module #(
	// Parameters with default values
	parameter PARAM1 = 1,
	parameter PARAM2 = 2
)(
	input in,
	output out
);

	/* ... */

endmodule

// Instantiation of the module above
some_module #(
	.PARAM1(param1),
	.PARAM2(param2)
) instance_name (
	/* ... */
);
\end{lstlisting}

Functions: only combinational circuits, no registers, delays and non-blocking assignments (are defined in the module in which they are used, can call other functions).
\begin{lstlisting}
function my_xor;
	input a, b;

	begin
		my_xor = a ^ b;
	end
endfunction

assign y = my_xor(c, d);
\end{lstlisting}

Tasks: no return value, can have \lstinline!ouput! and \lstinline!inout! ports, can have delays
\begin{lstlisting}
task my_inverter;
	// FIXME
\end{lstlisting}

\lstinline!generate! Blocks:
\begin{lstlisting}
	// FIXME
\end{lstlisting}

Compiler directives: FIXME
%
%
%
%
\subsection{Simulation}
Register data types: \lstinline!integer!, \lstinline!real!, \lstinline!time!

Initial blocks:
\begin{lstlisting}
module testbench;
	initial begin
		$display("Hello world!);
		$finish;
	end
endmodule
\end{lstlisting}

Delays: \lstinline!#10;!

System tasks: \lstinline!$display("Format string", /* ... */)!

\lstinline!$monitor("Format string", /* ... */)!: automatically generates output when one of the values changes

VCD (Value Change Dump) files:
\begin{lstlisting}
$dumpfile("traces.vcd")
$dumpvars(0, testbench)
\end{lstlisting}
%
%
%
%
%
\section{VHDL}
\lstset{language=vhdl,
        morecomment=[s]{/*}{*/}}
\subsection{Lexical Elements}
Types of \emph{comments} (can't be nested):
\begin{lstlisting}
-- Single line comment
/* Comment spanning multiple
   lines (VHDL-2008 only) */
\end{lstlisting}

Valid \emph{identifiers} consist of the characters \lstinline!'a'!--\lstinline!'z'!, \lstinline!'A'!--\lstinline!'Z'!, \lstinline!'0'!--\lstinline!'9'!, \lstinline!'_'! and may only start with an alphabetic letter. Identifiers with more than one consecutive underscore or identifiers that end with an underscore are illegal. Furthermore, identifiers aren't case sensitive in VHDL.

Examples of \emph{numeric literals}:
\begin{lstlisting}
-- Integer literals (base 10)
1 42 10e5 10E6
1_234           -- identical to 1234, underscores get ignored

-- Real literals (base 10, always contain the decimal point '.' character)
3.1415927 1.6022e-19 8.8542E-12

-- Other bases
2#10101010#   -- binary integer
8#777#        -- octal integer
16#aa# 16#FF# -- hexadecimal integer
2#1.101#      -- binary real
\end{lstlisting}

Examples of \emph{character and string literals}:
\begin{lstlisting}
-- Characters (ISO 8859 Latin-1 8 bit character set)
'a' 'b' 'X' '_'
'''             -- single quote

-- Strings (may not be separated by linebreaks)
"Hello world!"
""""           -- double quote
""             -- empty string
\end{lstlisting}

\newpage
\emph{Bit string literals} are enclosed in double quotes with a prefix that indicates the size of the string in bits (\textsc{VHDL-2008} only) and the base. Examples:
\begin{lstlisting}
b"101010" B"1111_0000" -- binary (underscores are ignored)
o"777" O"777"          -- octal
x"aabb" X"FFFF"        -- hexadecimal

-- VHDL-2008 only
8b"1111_0000" -- 8 bit long binary number
d"42" D"23"   -- decimal number, size can't be specified

X"0X1"       -- equivalent to B"0000XXXX1111"
B"1111_ZZ00" -- equivalent to B"1111ZZ00"

UB"" UO"" UX"" -- unsigned binary, octal, hexadecimal
SB"" SO"" SX"" -- signed     "       "         "
\end{lstlisting}
%
%
%
%
\subsection{Fundamental Data Types}
Declaring \emph{constants} (one of several types of objects, namely constants, variables, signals and files):
\begin{lstlisting}
-- Syntax: constant identifier {, ...}: subtype [:= initial_value];
constant pi : real    := 3.1415927;
constant n  : natural := 42;
\end{lstlisting}

Declaring \emph{variables}:
\begin{lstlisting}
-- Syntax: variable identifier {, ...}: subtype [:= initial_value];
variable count : integer := 0;
variable x     : natural;
\end{lstlisting}

\emph{Assignments} to variables are non-blocking (in contrast to assignments to signals), i.e. the value of the variable gets updated immediately:
\begin{lstlisting}
-- Syntax: [label:] name := value;
x     := 1;
count := count + 1;
\end{lstlisting}

\emph{New types} can be declared using \lstinline!type identifier is definition;!.

Declaring new \emph{integer types}:
\begin{lstlisting}
-- Syntax: type identifier is range bound1  (to|downto) bound2
type day_of_week is range 0 to 6;

constant JAN : integer := 1;
constant DEC : integer := 12;
type month is range JAN to DEC;  -- bounds for range can be evaluated
                                 -- at compile time
\end{lstlisting}
Operations that are defined for integer types include \lstinline!+!, \lstinline !-!, \lstinline!*!, \lstinline!/!, \lstinline!mod!, \lstinline!rem!, \lstinline!abs! and \lstinline!**!.

New \emph{floating point types} are declared exactly as their integer counterparts, except the bounds for their range have to evaluate to real numbers. If the default value for floating point variables is left out, they default to the lowest possible value.

\emph{Physical types} include a physical unit and can be declared as follows:
\begin{lstlisting}
-- Syntax:
-- type identifier is range bound1 (to|downto) bound2
-- 	units
-- 		identifier;
-- 		{identifier2 = (integer/real) unit;}
-- 	end units [identifier];

type voltage is range 0 to 1e9
	units
		volt;              -- base unit
		kvolt = 1000 volt;
	end units voltage;
\end{lstlisting}
VHDL includes a predefined physical type \lstinline!time!, that defines the following unit prefixes: \lstinline!fs!, \lstinline!ps!, \lstinline!ns!, \lstinline!us!, \lstinline!ms!, \lstinline!sec!, \lstinline!min! and \lstinline!hr!.

Examples of \emph{enumeration types}:
\begin{lstlisting}
-- Syntax: type identifier is ( (identifier|character literal) {, ...} );
type fsm_state is (reset, state1, state2);
variable state : fsm_state := reset;

type hexdigit is ('0','1','2','3','4','5','6','7','8','9',
                   'a','b','c','d','e','f'); -- lowercase hex digits
variable x : hexdigit := 'a';

-- Predefined character enumeration type
variable c : character := 'x';
\end{lstlisting}

The predefined \lstinline!boolean! enumeration type can take the values \lstinline!true! and \lstinline!false!. Valid expressions including booleans may use the operators \lstinline!=! (is equal), \lstinline!/=! (is not equal), \lstinline!and!, \lstinline!or!, \lstinline!nand!, \lstinline!nor!, \lstinline!not!, \lstinline!xor! and \lstinline!xnor!.

Predefined \lstinline!bit! type: \lstinline!type bit is ('0', '1');! (overloads \lstinline!'0'! and \lstinline!'1'! character literals).

Declaring subtypes:
\begin{lstlisting}
-- Syntax: subtype identifier is type range bound1 (to|downto) bound2;
subtype uint8 is integer range 0 to 255;

variable b : uint8 := 255;

-- Predefined subtype for delays >=0 fs
variable delay : delay_length;
\end{lstlisting}

The \emph{type qualification} operator \lstinline!typename'(expression)! can be used to distinguish between overloaded enumeration literals:
\begin{lstlisting}
type fsm1_state is (reset, a1, a2);
type fsm2_state is (reset, b1, b2);

fsm1_state'(reset) -- type of 'reset' literal: fsm1_state
fsm2_state'(reset) -- type of 'reset' literal: fsm2_state
\end{lstlisting}

Examples for \emph{type conversions}:
\begin{lstlisting}
real(42)         -- integer to real
integer(2.71828) -- real to integer
\end{lstlisting}

List of \emph{attributes} applicable to scalar data types (\lstinline!T! denotes a type name):

%\centering
\begin{tabular}{lll}
\toprule
	\textbf{Attribute} & \textbf{Description}\\
\midrule
	\lstinline!T'ascending! & \lstinline!True!: ascending range, \lstinline!false!: descending range \\
	\lstinline!T'low! & Lowest possible value\\
	\lstinline!T'high! & Highest possible value\\
	\lstinline!T'left! & Leftmost element\\
	\lstinline!T'right! & Rightmost element\\
	\lstinline!T'image(value)! & Converts \lstinline!value! to string representation\\
	\lstinline!T'value(string)! & Converts \lstinline!string! to value\\
\bottomrule
\end{tabular}


List of additional attributes applicable to discrete and physical types:

%\centering
\begin{tabular}{lll}
\toprule
	\textbf{Attribute} & \textbf{Description}\\
\midrule
	\lstinline!T'pos(value)! & Index of \lstinline!value!\\
	\lstinline!T'val(j)! & Value at index \lstinline!j!\\
	\lstinline!T'succ(value)! & \lstinline!Value! incremented by one\\
	\lstinline!T'pred(value)! & \lstinline!Value! decremented by one\\
	\lstinline!T'leftof(value)! & Element to the left of \lstinline!value!\\
	\lstinline!T'rightof(value)! & Element to the right of \lstinline!value!\\
\bottomrule
\end{tabular}
\end{document}
